import os
import matplotlib.pyplot as plt
import argparse

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
# Input file generated by network-load-balance.cc
PFC_FILE = os.path.join(BASE_DIR, "..", "..", "output", "out_pfc.txt")
OUT_DIR = os.path.join(BASE_DIR, "..", "figures")
OUT_PNG = os.path.join(OUT_DIR, "pfc_plot.png")

# Ensure output directory exists
if not os.path.exists(OUT_DIR):
    os.makedirs(OUT_DIR)

def parse_pfc(file_path):
    """
    Parse PFC data.
    Format: timestamp(ns) nodeID nodeType InterfaceIdx type(0:resume, 1:pause)
    nodeType: 0=Server, 1=Switch
    """
    data = {} # (nodeType, nodeID, port) -> {'times': [], 'state': []}
    if not os.path.exists(file_path):
        return data

    with open(file_path, "r") as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) != 5:
                continue
            try:
                t_ns = int(parts[0])
                node_id = int(parts[1])
                node_type = int(parts[2])
                port = int(parts[3])
                pfc_type = int(parts[4])
                
                key = (node_type, node_id, port)
                if key not in data:
                    data[key] = {'times': [], 'state': []}
                
                data[key]['times'].append(t_ns / 1e6) # Convert to ms
                data[key]['state'].append(pfc_type)
            except ValueError:
                continue
    return data

def parse_include_label(lbl: str):
    """
    Accept:
    SW{node}-P{port} -> (1, node, port)
    H{node}-P{port} -> (0, node, port)
    """
    s = lbl.strip().upper()
    if s.startswith("SW"):
        node_type = 1
        body = s[2:]
    elif s.startswith("H"):
        node_type = 0
        body = s[1:]
    else:
        # Try default to Switch if no prefix
        if "-" in s:
            parts = s.split("-")
            if parts[0].isdigit():
                node_type = 1 # Default to switch
                body = s
            else:
                return None
        else:
            return None
    
    parts = body.split("-")
    if len(parts) != 2:
        return None
    node_str, port_str = parts[0], parts[1]
    if port_str.startswith("P"):
        port_str = port_str[1:]
    
    if node_str.isdigit() and port_str.isdigit():
        return (node_type, int(node_str), int(port_str))
    return None

def main():
    parser = argparse.ArgumentParser(description="Plot PFC Pause/Resume events over time.")
    parser.add_argument(
        "--include",
        nargs="*",
        help="Optional list of labels to keep. e.g., SW2-P1 H0-P1",
    )
    parser.add_argument(
        "--time",
        nargs=2,
        type=float,
        metavar=('START', 'END'),
        help="Time range to plot in seconds (e.g., --time 2.0 2.02)",
    )
    args = parser.parse_args()

    data = parse_pfc(PFC_FILE)
    if not data:
        print("No data found in {}".format(PFC_FILE))
        return

    # Filter keys
    include_keys = None
    if args.include:
        include_keys = set()
        for lbl in args.include:
            k = parse_include_label(lbl)
            if k:
                include_keys.add(k)
    
    plot_keys = sorted(data.keys())
    if include_keys:
        plot_keys = [k for k in plot_keys if k in include_keys]
    
    if not plot_keys:
        print("No matching data to plot.")
        if args.include:
            print("Available keys in data: {}".format(list(data.keys())))
        return

    # Define different line styles and markers for better distinction
    line_styles = ['-', '--', '-.', ':']
    markers = ['o', 's', '^', 'v', 'D', 'p', '*', 'h']
    
    plt.figure(figsize=(12, 6))
    
    any_plotted = False
    for idx, key in enumerate(plot_keys):
        node_type, node_id, port = key
        label = "{}{}-P{}".format("SW" if node_type == 1 else "H", node_id, port)
        
        times = data[key]['times']
        states = data[key]['state']
        
        if args.time:
            t_start_ms = args.time[0] * 1000
            t_end_ms = args.time[1] * 1000
            
            # Filter indices
            filtered_indices = [i for i, t in enumerate(times) if t_start_ms <= t <= t_end_ms]
            if not filtered_indices:
                continue
            
            times = [times[i] for i in filtered_indices]
            states = [states[i] for i in filtered_indices]

        if not times:
            continue

        # Use different styles for each line
        linestyle = line_styles[idx % len(line_styles)]
        marker = markers[idx % len(markers)]
        linewidth = 2 + (idx % 3) * 0.4  # Vary linewidth
        alpha = 0.85  # Add some transparency
        
        # Add markers at state transitions for better visibility
        markevery = max(1, len(times) // 15)
        
        plt.step(times, states, where='post', label=label, linewidth=linewidth,
                linestyle=linestyle, marker=marker, markersize=5, 
                markevery=markevery, alpha=alpha)
        any_plotted = True

    if not any_plotted:
        print("No data points in the specified time range.")
        return

    plt.xlabel("Time (ms)")
    plt.ylabel("PFC State (1: Pause, 0: Resume)")
    plt.title("PFC Pause/Resume Events")
    plt.ylim(-0.1, 1.1)
    plt.yticks([0, 1], ['Resume (0)', 'Pause (1)'])
    plt.legend(loc='best', ncol=2, framealpha=0.9, fontsize=9)
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.tight_layout()
    
    plt.savefig(OUT_PNG)
    print("Saved figure to {}".format(OUT_PNG))

if __name__ == "__main__":
    main()

