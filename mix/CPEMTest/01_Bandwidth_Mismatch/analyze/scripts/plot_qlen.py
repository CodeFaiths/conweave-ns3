import os
import matplotlib.pyplot as plt
import argparse

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
# Input file generated by network-load-balance.cc
QLEN_FILE = os.path.join(BASE_DIR, "..", "..", "output", "out_qlen.txt")
OUT_DIR = os.path.join(BASE_DIR, "..", "figures")
OUT_PNG = os.path.join(OUT_DIR, "qlen_plot.png")

# Ensure output directory exists
if not os.path.exists(OUT_DIR):
    os.makedirs(OUT_DIR)

def parse_qlen(file_path):
    """
    Parse queue length data from CSV-like file.
    Format: timestamp(ns), switchId, portId, ingressBytes, egressBytes
    """
    data = {} # (sw, port) -> {'times': [], 'ingress': [], 'egress': []}
    if not os.path.exists(file_path):
        return data

    with open(file_path, "r") as f:
        for line in f:
            parts = line.strip().split(",")
            if len(parts) != 5:
                continue
            try:
                t_ns = int(parts[0])
                sw = int(parts[1])
                port = int(parts[2])
                ing = int(parts[3])
                eg = int(parts[4])
                
                key = (sw, port)
                if key not in data:
                    data[key] = {'times': [], 'ingress': [], 'egress': []}
                
                data[key]['times'].append(t_ns / 1e6) # Convert to ms
                data[key]['ingress'].append(ing / 1000.0) # Convert to KB
                data[key]['egress'].append(eg / 1000.0) # Convert to KB
            except ValueError:
                continue
    return data

def parse_include_label(lbl: str):
    """Accept SW{node}-P{port}, S{node}-{port}, or SW{node}-{port} -> return (node, port)."""
    s = lbl.strip().upper()
    if not s:
        return None
    if s.startswith("SW"):
        body = s[2:]
    elif s.startswith("S"):
        body = s[1:]
    else:
        return None
    parts = body.split("-")
    if len(parts) != 2:
        return None
    node_str, port_str = parts[0], parts[1]
    if port_str.startswith("P"):
        port_str = port_str[1:]
    if node_str.isdigit() and port_str.isdigit():
        return (int(node_str), int(port_str))
    return None

def main():
    parser = argparse.ArgumentParser(description="Plot Ingress and Egress queue length over time.")
    parser.add_argument(
        "--include",
        nargs="*",
        help="Optional list of port labels to keep. e.g., SW2-P1 SW2-P2",
    )
    parser.add_argument(
        "--time",
        nargs=2,
        type=float,
        metavar=('START', 'END'),
        help="Time range to plot in seconds (e.g., --time 2.0 2.02)",
    )
    args = parser.parse_args()

    data = parse_qlen(QLEN_FILE)
    if not data:
        print("No data found in {}".format(QLEN_FILE))
        return

    # Filter ports
    include_pairs = None
    if args.include:
        include_pairs = set()
        for lbl in args.include:
            pair = parse_include_label(lbl)
            if pair:
                include_pairs.add(pair)
    
    plot_keys = sorted(data.keys())
    if include_pairs:
        plot_keys = [k for k in plot_keys if k in include_pairs]
    
    if not plot_keys:
        print("No matching ports found to plot.")
        return

    # Time range filtering (convert seconds to ms)
    t_start_ms = args.time[0] * 1000.0 if args.time else None
    t_end_ms = args.time[1] * 1000.0 if args.time else None

    # Limit number of ports if too many
    if not include_pairs and len(plot_keys) > 8:
        print("Too many ports ({}), only plotting first 8. Use --include to specify.".format(len(plot_keys)))
        plot_keys = plot_keys[:8]

    # Define different line styles and markers for better distinction
    line_styles = ['-', '--', '-.', ':']
    markers = ['o', 's', '^', 'v', 'D', 'p', '*', 'h']
    
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), sharex=True)

    has_data_to_plot = False
    for idx, key in enumerate(plot_keys):
        d = data[key]
        
        # Filter by time
        times = d['times']
        ingress = d['ingress']
        egress = d['egress']
        
        if t_start_ms is not None and t_end_ms is not None:
            filtered_indices = [i for i, t in enumerate(times) if t_start_ms <= t <= t_end_ms]
            if not filtered_indices:
                continue
            times = [times[i] for i in filtered_indices]
            ingress = [ingress[i] for i in filtered_indices]
            egress = [egress[i] for i in filtered_indices]

        if not times:
            continue
            
        has_data_to_plot = True
        label = "SW{}-P{}".format(key[0], key[1])
        
        # Use different styles for each line
        linestyle = line_styles[idx % len(line_styles)]
        marker = markers[idx % len(markers)]
        linewidth = 1.5 + (idx % 3) * 0.3  # Vary linewidth slightly
        alpha = 0.85  # Add some transparency
        
        # Add markers every N points to distinguish lines
        markevery = max(1, len(times) // 20)  # Show about 20 markers per line
        
        ax1.plot(times, ingress, label=label, linewidth=linewidth, 
                linestyle=linestyle, marker=marker, markersize=4, 
                markevery=markevery, alpha=alpha)
        ax2.plot(times, egress, label=label, linewidth=linewidth, 
                linestyle=linestyle, marker=marker, markersize=4, 
                markevery=markevery, alpha=alpha)

    if not has_data_to_plot:
        print("No data points found in the specified time range.")
        plt.close(fig)
        return

    ax1.set_ylabel("Ingress Queue (KB)", fontsize=12)
    ax1.set_title("Switch Port Queue Length over Time", fontsize=14)
    ax1.grid(True, linestyle=":", alpha=0.5)
    ax1.legend(fontsize=8, loc='best', ncol=2, framealpha=0.9)

    ax2.set_ylabel("Egress Queue (KB)", fontsize=12)
    ax2.set_xlabel("Time (ms)", fontsize=12)
    ax2.grid(True, linestyle=":", alpha=0.5)
    ax2.legend(fontsize=8, loc='best', ncol=2, framealpha=0.9)

    plt.tight_layout()
    plt.savefig(OUT_PNG, dpi=200)
    print("Saved figure to {}".format(OUT_PNG))

if __name__ == "__main__":
    main()
